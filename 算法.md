## 二叉树

### dfs 细节

1. 有时候要进行叶节点判断，而不是直接在 root == nullptr 的时候返回答案。

```c++
/**
 * 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum
**/

class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        // null_ptr
        if (root == nullptr) {
            return false;
        }
        // leaf node
        if (root->left == nullptr && root->right == nullptr) {
            return sum == root->val;
        }
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
};
```





## 二分

二分苦手。。。

#### lower_bound 用 [0,n) 比较好理解

#### upper_bound 用 [0,n) 比较好理解



#### find_first 就是 lowerbound

搜索 [l, r] 直到 l == r + 1, 需要检查 l 下标是不是越界，是不是找到了

#### find_last 就是 upperbound - 1,

[l, r] 直到 l == r + 1，**返回r** 需要检查 r 下标是不是越界，是不是找到了

**target不在 l 左边，也不在 r 右边**

搜索旋转排序数组

[l, r] (L <= R) 左闭右闭区间，如果 mid == left == right, left++, right--

1. 除了边界情况
2. 看是不是命中了
3. 检查重复 num[mid] == num[l] == num[r]
4. 看在哪一边  if (nums[l] <= nums[mid])
   1. 在左边，再看
      1. 是不是target也在左边 nums[l] <= target && target < nums[mid]) 
         1. 在更新 r
         2. 否则更新 l
   2. 在右边
      1. 看是不是target在右边 nums[mid] < target && target <= nums[n - 1]) 
         1. target不在右边，更新 l
         2. target不在右边，更新 r

```C++
// 无重复    
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
			// 这里l换成0也可以
            if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } 

            else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
```

```c++
// 有重复
		while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return true;
            }

            // dont know which part
            if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
                ++l;
                --r;
            } 

            else if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } 
            
            else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
```



旋转排序数组最小值 (L < R) 左闭右闭

**target总是在 [l, r] 中**

要找最小值，所以结束条件是 (l < r) 搜索到只有一个元素

* mid 在右边，更新r，最小值也在右边，所以只能收缩到 r = mid
* 否则，更新 l = mid + 1



```C++
// 带重复的旋转数组最小值
// 这里是 L < R 因为 l==r 的时候就是答案了，答案是一定存在的
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;

            // right part
            if (nums[mid] < nums[r]) {
                r = mid;
            }

            // left part
            else if (nums[mid] > nums[r]) {
                l = mid + 1;
            }
			// 把这个去掉就可以判断非重复的
            else {
                r--;
            }
        }
        return nums[l];
    }
};
```

