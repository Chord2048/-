[toc]



## STL 用法

#### priority queue 自定义比较

```c++
struct MyObj
{
    // 对象中的数据成员
};
// 仿函数，重载了 () 的 struct
struct HeapCmp
{
    bool operator()(const MyObj& o1, const MyObj& o2) const
    {
        // 比较逻辑：什么叫 o1 小于 o2
    }
};
// 仿函数作为第三个参数
priority_queue<MyObj, vector<MyObj>, HeapCmp> pq;

```



## 滑动窗口

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
// 找和为 target 的连续子数组。
int main() {
    vector<int> test{6, 3, 1, 2, 3, 1, 5, 2, 4, 6};
    int target = 6;
    int i = 0;
    int n = test.size();
    int sum = 0;
    for (int j = 0; j < n; j++) {
        // 向右移动一步右指针
        sum += test[j];
        // 移动左指针
        while (sum >= target) {
            // 移动前判断，一直移动到小于 target。极端情况下，l+1 == r。sum 会变成 0。
            if (sum == target) {
                cout << "find " << i << " " << j << endl;
            }
            sum -= test[i++];
        }
    } 
    return 0;
}
```





## 二叉树

### dfs 细节

1. 有时候要进行叶节点判断，而不是直接在 root == nullptr 的时候返回答案。

```c++
/**
 * 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum
**/

class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        // null_ptr
        if (root == nullptr) {
            return false;
        }
        // leaf node
        if (root->left == nullptr && root->right == nullptr) {
            return sum == root->val;
        }
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
};
```

## 字符串相关

### 常用的库函数别忘了

#### find(string target, int start=0)

* 找不到的时候返回 string::npos

#### substr(int start, int count)

* 从 start 开始，提取 count 个字符

#### 字符串转换相关

##### std::stoi, std::stol, std::stoll

```c++
int stoi (const std::string& str, std::size_t* pos = nullptr, int base = 10);
int stoi (const std::wstring& str, std::size_t* pos = nullptr, int base = 10);

long stol (const std::string& str, std::size_t* pos = nullptr, int base = 10);
long long stoll (const std::string& str, std::size_t* pos = nullptr, int base = 10);

// 16进制转换
string out = "1A";
// 中间有个很恶心的 nullptr 记得加上
int x = stoi(out, nullptr, 16);
cout << x <<endl;
 // 输出：26
```



## 二分

二分苦手。。。

#### lower_bound 用 [0,n) 比较好理解

#### upper_bound 用 [0,n) 比较好理解



#### find_first 就是 lowerbound

搜索 [l, r] 直到 l == r + 1, 需要检查 l 下标是不是越界，是不是找到了

#### find_last 就是 upperbound - 1,

[l, r] 直到 l == r + 1，**返回r** 需要检查 r 下标是不是越界，是不是找到了

**target不在 l 左边，也不在 r 右边**

搜索旋转排序数组

一直搜索到不合法

[l, r] (L <= R) 左闭右闭区间，如果 mid == left == right, left++, right--

1. 除了边界情况
2. 看是不是命中了
3. 检查重复 num[mid] == num[l] == num[r]
4. 看在哪一边  if (nums[l] <= nums[mid])
   1. 在左边，再看
      1. 是不是target也在左边 nums[l] <= target && target < nums[mid]) 
         1. 在更新 r
         2. 否则更新 l
   2. 在右边
      1. 看是不是target在右边 nums[mid] < target && target <= nums[n - 1]) 
         1. target不在右边，更新 l
         2. target不在右边，更新 r

```C++
// 无重复    
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
			// 这里l换成0也可以
            if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } 

            else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
```

```c++
// 有重复
		while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return true;
            }

            // dont know which part
            if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
                ++l;
                --r;
            } 

            else if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } 
            
            else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
```



旋转排序数组最小值 (L < R) 左闭右闭

**target总是在 [l, r] 中**

**要找最小值，所以结束条件是 (l < r) 搜索到只有一个元素**

* mid 在右边，更新r，最小值也在右边，所以只能收缩到 r = mid
* 否则，更新 l = mid + 1



```C++
// 带重复的旋转数组最小值
// 这里是 L < R 因为 l==r 的时候就是答案了，答案是一定存在的
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;

            // right part
            if (nums[mid] < nums[r]) {
                // 这里很重要
                r = mid;
            }

            // left part
            else if (nums[mid] > nums[r]) {
                l = mid + 1;
            }
			// 判断重复值
            else {
                r--;
            }
        }
        return nums[l];
    }
};
```

