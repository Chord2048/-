### OB 下去又没有了解？

存储引擎

传统问题 ： 

* **随机写** Buffer Pool 内存中 BufferPool紧凑，硬盘中离散，产生**随机写问题**。
* **写放大**：只写了一两个字段，但是需要写回整个页。
* 





#### 看了一下OB的存储结构

##### 存储引擎 LSM Tree 架构

数据分为 

静态基线数据SStable（只读） 

动态增量数据Memtable



内存分为

增量数据写内存

热点缓存读内存



内存数据库+LSMTree好处

* 避免随机写
* 读写分离
* 提高写速度，准内存操作
* 数据持久性 redo-log WAL
* 降低成本 压缩，减少**磁盘碎片**





事务处理



### OB和LSMtree区别

插入：布隆过滤器判断是否重复

更新：只更新特定字段，不一定包含全部列的数据

删除：主键+删除标记，以及范围删除标记

查询：

多级缓存：block cache， Row Cache

数据校验



Ob 的 mentable 由 bTree 和hashtable 组成

宏块：写IO的基本单位

微块：读IO的基本单位



过滤算子下压到存储层





### 向量化执行

适用OLAP查询





### 执行计划优化

### 索引优化

**减少读行**：table filter

explain 看执行计划

创建索引缩小 Query Range

**避免回表**

创建覆盖索引：

When IO压力大且由随机IO导致，高频查询的列并不多。

**避免排序**

建立索引/联合索引

### 连接优化

基表路径：选择扫描方式

连接算法：nested loop join、merge join、hash join

连接次序：决策最优的连接次序



优化器通过计算 I/O 、网络和 CPU 开销来估计查询计划的成本

* nested loop join 的成本取决于将外部表的每一行及其内部表的每个匹配行读入内存的成本。 优化器使用**内部表的统计信息**来估计这些成本
* merge join 的成本在很大程度上取决于将所有源**读入内存并对它们进行排序**的成本。
* hash join 的成本在很大程度上取决于在连接的输入端之一**构建哈希表**并使用连接另一端的行来**探测它的成本**。



#### Nested Loop Join

**小的数据集与大的数据集**，并且对于大的数据集，满足连接条件的数据量很少或者只需要输出满足条件的第一行时

**或者不存在等值连接，或者没有连接条件**



#### Hash Join

Hash Join 的原理是**使用左表的数据构建哈希表**，右表通过**探测哈希表**的方式完成连接运算。其执行过程的伪代码如下所示。

**条件：**当需要 join 的数据量比较大时的等值连接

为了更好的使用 Hash Join 算法，在控制优化器时需要注意以下两点：

- 尽量使用**数据量比较小的数据源构建哈希表**，也就是作为驱动表。
- **不能对非等值连接**使用 Hash Join 算法。



#### Merge Join

为了更好的使用 Merge Join 算法，在控制优化器时需要注意以下两点：

- 尽量在数据源有序的情况下选择 Merge Join。
- 不能对**非等值连接**使用 Merge Join 算法。



### 连接次序

影响优化器决策连接次序的因素非常多，例如：**连接的数据量**、**表的列访问量**、**数据分布情况**、**连接算法**以及**数据表的索引**。

其中最容易影响优化器选择连接次序的因素是**连接数据量**，这个因素取决于统计信息的准确度以及优化器的行数估计。
