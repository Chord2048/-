## 

[toc]



## 访问网页发生了什么？

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

### 应用层

1. 解析 URL 确定请求的 Web 服务器名和文件名
2. 生成 Http 请求信息
3. 域名解析 DNS
   1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务。
   2. 本地域名服务器收到客户端的请求后，如果**缓存**里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去**问它的根域名服务器**：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
   3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com **顶级域名服务器地址**给你，你去问问它吧。”
   4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
   5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
   6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
   7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
   8. **本地 DNS 再将 IP 地址返回客户端**，客户端和目标建立连接。

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)





请求报文

* **请求行** 方法、URL、版本
* **消息头** [首部 : 字段值] * n
* **消息体** ：数据（JSON）



响应报文

* **请求行** 版本 状态码
* **消息头** [首部 : 字段值] * n
* **消息体** ：数据（JSON）



URL解析





## TCP

原端口号 目的端口号

序号 确认序列

窗口大小（**流量控制**）

状态位

* SYN 发起连接
* ACK 回复
* RST 重新连接
* FIN 结束连接



IP 报文

协议 源IP 目的 IP 协议号





### HTTP

状态码：

* 1xx 提示信息
* 2xx **成功 200** 204 206
* 3xx 客户端请求的资源发生变动，重定向
* 4xx 错误码
  * 400 bad request
  * 403 forbidden
  * 404 找不到
* 5xx 服务器处理出错

### 字段

#### connection

keep-Alive 长连接



#### 强制缓存 ： 不过期则用本地缓存，Response 头部加上 Cache-Control 设置 Cache 过期时间大小

#### 协商缓存：可以使用本地缓存 Etag & IFNONEMATCH // IFMODIFIEDSINCE。LAST MODIFIED

### GET vs POST

GET 请求资源 用 url传输

POST 请求负荷对指定的资源作出处理 （留言）用body传输









## HTTP特点

简单，灵活可扩展，跨平台

1. 无状态：减轻负担但是难以处理关联操作
2. 明文传输
3. 不安全：通信明文，不用验证身份，不验证报文完整性



### HTTP1.1 

长连接 管道化请求解决请求队头阻塞问题



HTTP vs HTTPs

HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险（**窃听**、**篡改**、**冒充**）：

- **信息加密**：交互信息**无法被窃取**，但你的号会因为「自身忘记」账号而没。
- **校验机制**：**无法篡改**通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- **身份证书**：证明淘宝是**真的淘宝网**，但你的钱还是会因为「剁手」而没。



篡改：内容哈希 + 数字签名（**私钥加密，公钥解密**）

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**



数字证书 CA ：服务器把公钥注册到CA



#### TLS握手

**TCP三次握手**

1. **ClientHello** ：客户端发随机数Client Random，版本号
2. **ServerHello** ：ACK 会应是否支持、随机数ServerRandom、密码套件列表、数字证书
3. **Client回应**：用 **CA 公钥 **验证数字证书，取出服务器公钥，发送随机数Premaster Key + 使用会话密钥通知 + 握手结束
4. 服务器最后回应

#### 中间人攻击

接受了中间人的证书

解决：HTTPS 双向验证





### HTTP1.1 HTTP2 HTTP3 演变

**HTTP1.1** 加入长连接，支持管道传输（请求发出去不用等待响应就能发送下一个请求）

**HTTP2** 基于 HTTPS 安全性有保障，支持**头部压缩**，**二进制格式**，**并发传输**和**服务器主动推送**

* **头部压缩**，维护头信息表相同字段只传索引号。
* **二进制格式**，头信息帧➕数据帧
* **并发传输**，并发交错处理不同的stream （多路复用） **多条stream 复用一条TCP连接** 不同http用不同streamid标识
* **服务器推送**：服务器可以主动发消息

缺点：TCP丢包会阻塞所有 HTTP 请求（**TCP层队头阻塞**）

**HTTP3 优化**：把TCP改成UDP 用 QUIC实现可靠传输（无队头阻塞、更快连接、连接迁移）

* **无阻塞**：

​	QUIC 有自己的一套机制可以保证传输的可靠性的。**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。

* 更快连接

  QUIC 协议握手只需要一个 RTT 。省去了 TLS 握手

* 连接迁移

  没有用四元组绑定链接，而是用连接 ID。普及缓慢

  、



HTTP 和 RPC 区别

**服务发现**：HTTP 通过 DNS 查询，RPC 一般要找中间服务器找服务的 IP

**连接形式**： RPC 一般会用连接池提升网络请求性能

**传输内容**：**JSON序列化** vs **定制化用其他序列化协议** 不用和处理器打交道，

性能更好





#### **WebSocket 全双工**

### WebSocket的使用场景

WebSocket完美继承了 TCP 协议的**全双工**能力，并且还贴心的提供了解决**粘包**的方案。

它适用于**需要服务器和客户端（浏览器）频繁交互**的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。

回到文章开头的问题，在使用 WebSocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是**服务器逻辑**产生的，对玩家产生的伤害等数据，都需要由**服务器主动发送给客户端**，客户端获得数据后展示对应的效果。





窗口关闭：发送了 ACK 但是因为OS缓冲区繁忙，应用程序没有接受到数据，导致窗口不能增大（逐渐关闭）。

操作系统还可能直接减少接收缓冲区大小，导致数据包丢失。

**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**



**窗口关闭问题**：发送方关闭窗口，接收方发送窗口大小改变ACK但是丢失了，于是死锁。

**糊涂窗口问题**解决：

- 让接收方不通告小窗口给发送方
- 让发送方避免发送小数据

**拥塞窗口 cwnd**

**慢启动阈值**

拥塞控制主要是四个算法：

- 慢启动：指数增长
- 拥塞避免：超过阈值后每收到一个ACK cwnd+1
- 拥塞发生：发生重传，进入拥塞发生阶段
  - 超时重传 ssthresh = cwnd / 2； cwnd = 1
  - 快速重传 cwnd = cwnd/2，ssthresh = cwnd；然后快速恢复
    - 快速恢复 cwnd = ssthresh + 3
    - 重传丢包
    - 收到重复 ACK 则 cwnd + 1
    - 收到新 ACK 则 cwnd = ssthresh 因为已经收到了数据，恢复过程结束。
    - 
- 快速恢复







网络排查：

  当出现客户端与服务器端收不到对方的请求或响应时，按照以下流程排查问题：
1，抓包。分别抓客户端和服务端的网络数据包，看数据是否发送出去或者接收到。（TCP协议是可靠的，不存在丢包问题）
2，如果服务端没有发出响应包，则排查服务端的发包流程是否正常。
3，如果服务端有发出数据包，客户端也有收到，那么排查客户端的收包流程是否正常，特别是粘包，拆包的处理。
