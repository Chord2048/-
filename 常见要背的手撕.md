# æ‰‹æ’•

[TOC]

### å †

```c++
#include <iostream>
#include <vector>

// ä»¥ 0 ä¸ºå¼€å§‹ä¸‹æ ‡
// i çš„å·¦å­ i * 2 + 1
// i çš„å³å­ i * 2 + 2
// i çš„çˆ¶äº² (i - 1) / 2
class heap {
public:
    void push(int x) {
        _elems[size] = x;
        size++;
        shift_up(size-1);
    }
    int top() {
        return _elems[0];
    }
    void pop() {
        // æ³¨æ„æ˜¯ --size
        _elems[0] = _elems[--size];
        shift_down(0);
    }

    heap(int capacity) : cap(capacity), size(0), _elems(cap, 0){ }

private:
    int size;
    int cap;
    std::vector<int> _elems;
    void swap(int &a, int &b) {
        int temp = a;
        a = b;
        b = temp;
    }
    void shift_down(int pos) {
        while (pos * 2 + 1 < size) {
            int smaller_child = pos * 2 + 1;
            if (pos * 2 + 2 < size && _elems[smaller_child] > _elems[pos*2+2]) {
                smaller_child = pos * 2 + 2;
            }
            if (_elems[pos] > _elems[smaller_child]) {
                swap(_elems[pos], _elems[smaller_child]);
                pos = smaller_child;
            }
            else {
                break;
            }
        }
    }
    
    void shift_up(int pos) {
        while ((pos-1)/2 >= 0) {
            int parent = (pos-1) / 2;
            if (_elems[pos] < _elems[parent]) {
                swap(_elems[pos], _elems[parent]);
                pos = parent;
            }
            else {
                break;
            }
        }
    }
};

int main() {
    std::vector<int> test{1, 34, 42, 23, 12, 0};
    heap heap(100);
    for (auto e : test) {
        heap.push(e);
    }
    for (int i = 0; i < test.size(); i++) {
        std::cout << heap.top() << " ";
        heap.pop();
    }
    std::cout << std::endl;
    return 0;
}
```



###  å¿«é€Ÿæ’åº

```c++
#include <iostream>
#include <vector>
int partition(std::vector<int> &nums, int l, int r) {
    int pivot = nums[l];
    while (l < r) {
        while (l < r && nums[r] >= pivot) {
            r--;
        }
        nums[l] = nums[r];
        while (l < r && nums[l] <= pivot) {
            l++;
        }
        nums[r] = nums[l];
    }
    nums[l] = pivot;
    return l;
}
void quick_sort(std::vector<int> &nums, int l, int r) {
    if (l >= r) return;
    int mid = partition(nums, l, r);
    quick_sort(nums, l, mid-1);
    quick_sort(nums, mid+1, r);
}
int main() {
    std::vector<int> test = {1, 3, 2, 14, 12, 1};
    quick_sort(test, 0, test.size());
    for (auto e : test) {
        std::cout << e << " ";
    }
    std::cout << std::endl;
    return 0;
}
```



### å½’å¹¶æ’åº

```c++
#include <iostream>
#include <vector>
void merge(std::vector<int> &nums, int l1, int r1, int l2, int r2) {
    std::vector<int> temp;
    // è¿™é‡Œä¸€å®šè¦ä¿å­˜å¼€å§‹çš„ä½ç½®ï¼
    int left = l1;
    while (l1 <= r1 && l2 <= r2) {
        if (nums[l1] < nums[l2]) {
            temp.push_back(nums[l1]);
            l1++;
        }
        else {
            temp.push_back(nums[l2]);
            l2++;
        }
    }
    while (l1 <= r1) {
        temp.push_back(nums[l1++]);
    }
    while (l2 <= r2) {
        temp.push_back(nums[l2++]);
    }
	// ä»å¼€å§‹çš„ä½ç½®å¤åˆ¶
    for (int i = 0; i < temp.size(); i++) {
        nums[i + left] = temp[i];
    }
}
void merge_sort(std::vector<int> &nums, int l, int r) {
    if (l >= r) return;
    int mid = l + (r - l) / 2;
    merge_sort(nums, l, mid);
    merge_sort(nums, mid+1, r);
    merge(nums, l, mid, mid+1, r);
}
int main() {
    std::vector<int> test = {1, 3, 20, 6, 10, 7};
    merge_sort(test, 0, test.size()-1);
    for (auto &e : test) {
        std::cout << e << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

### å¹¶æŸ¥é›†

27 è¡Œ

```c++
class UF {
public:
    // åˆå§‹åŒ–ä¸º -1
    UF(int _sz) : size(_sz), _elems(size, -1) {}
    void Union(int x, int y) {
        int pa = find(x), pb = find(y);
        if (pa == pb) {
            return;
        }
        // è®© pa æ˜¯æ›´å¤šèŠ‚ç‚¹çš„æ ‘æ ¹
        if (_elems[pa] > _elems[pb]) {
            int temp = pa;
            pa = pb;
            pb = temp;
        }
        // é¡ºåºå¾ˆé‡è¦ï¼ä¸è¦æåäº†
        _elems[pa] += _elems[pb];
        _elems[pb] = pa;
    }
    // é€’å½’ã€‚è·¯å¾„å‹ç¼©
    int find(int x) {
        return _elems[x] < 0 ? x : _elems[x] = find(_elems[x]);
    }   
private:
    int size;
    std::vector<int> _elems;
};
```



### å‰ç¼€æ ‘

### LRU

```c++
class LRUCache {
public:
    class Node {
    public:
        int key;
        int val;
        Node *next;
        Node *prev;
        Node (int _key = -1, int _val = -1, Node *_next = nullptr, Node *_prev = nullptr) : key(_key), val(_val), next(_next), prev(_prev) {};        
    };
    
    unordered_map<int, Node*> mp;
    Node *head;
    Node *tail;    
    int capacity;
    int size;
    
    LRUCache(int capacity) : capacity(capacity), size(0) {
        head = new Node;
        tail = new Node;
        head->next = tail;
        tail->prev = head;
    }

    void release(Node *node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void move_head(Node *node) {
        Node *next = head->next;
        node->next = next;
        node->prev = head;
        head->next = node;
        next->prev = node;
    }

    int get(int key) {
        if (mp.find(key) == mp.end()) {
            return -1;
        }
        Node *node = mp[key];
        release(node);
        move_head(node);
        return node->val;
    }
    

    void put(int key, int value) {
        if (mp.find(key) != mp.end()) {
            Node *node = mp[key];
            // æ›´æ–°value
            node->val = value;
            // é‡æ–°æ’åˆ°å‰é¢
            release(node);
            move_head(node);
        }
        else {
            // æ»¡äº†å…ˆåˆ ï¼Œä»é“¾è¡¨å’Œå“ˆå¸Œé‡Œåˆ æ‰ï¼Œæ³¨æ„size--
            if (capacity == size) {
                Node *removed = tail->prev;
                release(removed);
                mp.erase(removed->key);
                delete removed;
                size--;
            }
            // åŠ æ–°èŠ‚ç‚¹ï¼ŒåŠ å…¥é“¾è¡¨å’Œå“ˆå¸Œï¼Œsize++
            Node *node = new Node(key, value);
            move_head(node);
            mp[key] = node;
            size++;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### TODO LFU

### ğŸ‰ğŸ‰ğŸ‰ å•ä¾‹æ¨¡å¼

https://shengyu7697.github.io/cpp-singleton-pattern/

#### é¥¿æ±‰æ¨¡å¼

ç¼ºé»æ˜¯å¦‚æœè©² Singleton **åˆå§‹åŒ–å¾ˆè€—æ™‚çš„è©±æœƒä½”ç”¨åˆ°é€²å…¥ main å‰çš„æ™‚é–“**ï¼Œå„ªé»æ˜¯åœ¨é€²å…¥ main ä¹‹å‰å°±å°‡ Singleton åˆå§‹åŒ–å¥½ï¼Œæ‰€ä»¥**ä¸æœƒæœ‰ thread-safe åŸ·è¡Œç·’å®‰å…¨**å•é¡Œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯åœ¨**å¤šå€‹ Singleton æœ‰ç›¸ä¾é—œä¿‚çš„è©±æœƒç”¢ç”Ÿå•é¡Œ**ï¼Œä¾‹å¦‚ SingletonA å’Œ SingletonB éƒ½æ¡ç”¨äº†é¤“æ¼¢æ¨¡å¼ã€‚

```c++
// g++ cpp-singleton-hungry.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
using namespace std;

class Singleton {
public:
    // é™æ€æ–¹æ³•ï¼Œè¿”å›å¼•ç”¨æˆ–è€…æŒ‡é’ˆã€‚
    static Singleton& getInstance() {
        this_thread::sleep_for(chrono::seconds(1));
        return sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }

    static Singleton sInstance;
    // æˆ–è€… static Singleton *instance
};
// éœ€è¦åˆå§‹åŒ–ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„ // å¦‚æœæ˜¯æŒ‡é’ˆ Singleton Singleton::sInstance = new Singleton;
// éœ€è¦ä¼ å…¥ç±»å‹åï¼Œå…¶å®å°±æ˜¯å®šä¹‰ä¸€ä¸ªé™æ€å˜é‡
Singleton Singleton::sInstance;

int main() {
    cout << "main" << endl;
    thread t1([]{
        cout << "singleton addr: " << &Singleton::getInstance() << endl;
    });
    cout << "singleton addr: " << &Singleton::getInstance() << endl;
    // åˆ«å¿˜äº† join
    t1.join();
    return 0;
}
```



#### æ‡’æ±‰æ¨¡å¼

å»¶é²åˆå§‹åŒ– (Lazy Initialization)ï¼Œé€™åœ¨ä¸€äº›åˆå§‹åŒ–æ™‚æ¶ˆè€—è¼ƒå¤§çš„æƒ…æ³æœ‰å¾ˆå¤§å„ªå‹¢ã€‚

ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

```c++
// g++ cpp-singleton-hungry.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
using namespace std;
class Singleton {
public:
    // é™æ€æ–¹æ³•ï¼Œè¿”å›å¼•ç”¨æˆ–è€…æŒ‡é’ˆã€‚
    static Singleton& getInstance() {
    	if (instance == nullptr) {
    		instance = new Singleton();
    	}
        this_thread::sleep_for(chrono::seconds(1));
        // è¿”å›è§£å¼•ç”¨
        return *sInstance;
    }
private:
	// ç§æœ‰çš„æ„é€ å‡½æ•°
    Singleton() {}
    static Singleton *instance;
};
// staticå˜é‡ç±»å¤–åˆå§‹åŒ–
Singleton* Singleton::sInstance = nullptr;
...
```

#### çº¿ç¨‹å®‰å…¨æ‡’æ±‰

##### æ™®é€šé”

```c++
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

class Singleton {
public:
    static Singleton& getInstance() {
        // è¿™é‡Œä¸Šä¸ªé”
        lock_guard<std::mutex> lock(sMutex);
        if (sInstance == nullptr) {
            this_thread::sleep_for(chrono::seconds(1));
            sInstance = new Singleton();
        }
        return *sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }
	// static mutexå¯¹è±¡
    static mutex sMutex;
    static Singleton* sInstance;
};

// åŠ ä¸€ä¸ªstatic é”
mutex Singleton::sMutex;
Singleton* Singleton::sInstance = nullptr;

int main() {
    cout << "main" << endl;
    thread t1([]{
        cout << "singleton addr: " << &Singleton::getInstance() << endl;
    });
    cout << "singleton addr: " << &Singleton::getInstance() << endl;
    t1.join();
    return 0;
}
```

##### åŒé‡é”

é »ç¹åœ°å‘¼å« getInstance æœƒé€ æˆ race condition å•é¡Œï¼Œç”¢ç”Ÿæ•ˆèƒ½ä½è½çš„æƒ…å½¢ï¼Œå› æ­¤æœ‰äº†é›™é‡æª¢æ¸¬ä¸Šé–ç‰ˆ Double-Checked Locking é€™å€‹ç‰ˆæœ¬çš„æ”¹è‰¯

è¿˜æ˜¯æœ‰é—®é¢˜ï¼šç•¶æœ‰ä¸€å€‹åŸ·è¡Œç·’åœ¨åŸ·è¡Œ `sInstance = new Singleton();`ï¼Œæœ‰å¦å¤–ä¸€å€‹åŸ·è¡Œç·’åœ¨æª¢æŸ¥ç¬¬ä¸€å€‹ `sInstance == nullptr` æ™‚å¾ˆæœ‰å¯èƒ½å‡ºç¾å•é¡Œ

å› ç‚º `sInstance = new Singleton();` é€™èªå¥æœƒåˆ†æˆä¸‰å€‹æ­¥é©Ÿï¼Œ
Step 1: **Allocate** memory to hold a Singleton object. è¨˜æ†¶é«”é…ç½®
Step 2: **Construct** a Singleton object in the allocated memory. åœ¨å·±ç¶“é…ç½®çš„è¨˜æ†¶é«”ä¸Šå»ºæ§‹ Singleton ç‰©ä»¶
Step 3: Make sInstance **point to** the allocated memory. å°‡ sInstance æŒ‡å‘é…ç½®çš„è¨˜æ†¶é«”

1-3-2 å…ˆæŒ‡å‘ä½†æ²¡æœ‰ç”¨æ„é€ å‡½æ•°ï¼Œè¿™æ—¶å€™è¢«å…¶ä»–çº¿ç¨‹ç›´æ¥æ‹¿æ¥ç”¨äº†ã€‚

```c++
// g++ cpp-singleton-lock2.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

class Singleton {
public:
    static Singleton& getInstance() {
        if (sInstance == nullptr) {
            // ç©ºäº†æ‰ä¸Šé”ï¼Œè¿™æ ·å†åˆå§‹åŒ–å®Œäº†å°±ä¸ä¼šç«äº‰äº†ã€‚
            lock_guard<std::mutex> lock(sMutex);
            // æ‹¿åˆ°é”å†æ£€æŸ¥ä¸€æ¬¡
            if (sInstance == nullptr) {
                sInstance = new Singleton();
            }
        }
        // åˆå§‹åŒ–è¿‡äº†ï¼Œç›´æ¥è¿”å›ï¼Œä¸ç”¨ä¸Šé”ã€‚
        return *sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }

    static mutex sMutex;
    static Singleton* sInstance;
};

mutex Singleton::sMutex;
Singleton* Singleton::sInstance = nullptr;
```

#### èƒŒä¸€æ‰‹

```c++
#include <iostream>
#include <thread>

class LazySingleton {
public:
    static LazySingleton *getInstance() {
        if (instance_ptr == nullptr) {
            instance_ptr = new LazySingleton;
        }
        return instance_ptr;
    }
private:
    LazySingleton () {}
    static LazySingleton *instance_ptr;
};
LazySingleton *LazySingleton::instance_ptr = nullptr;

class HungrySingleton {
public:
    static HungrySingleton *getInstance() {
        return instance_ptr;
    }

private:
    HungrySingleton () {}
    static HungrySingleton *instance_ptr;
};
HungrySingleton *HungrySingleton::instance_ptr = new HungrySingleton;

int main() {
    std::cout << "test lazy" << std::endl;
    auto s1 = LazySingleton::getInstance();
    auto s2 = LazySingleton::getInstance();
    std::cout << s1 << " " << (s1 == s2) << std::endl;

    std::cout << "test hungry" << std::endl;
    auto s3 = HungrySingleton::getInstance();
    auto s4 = HungrySingleton::getInstance();
    std::cout << s3 << " " << (s3 == s4) << std::endl;
    return 0;
}
```

#### æœ€å¥½ç”¨çš„æ‡’æ±‰

// å±€éƒ¨local å†å‡½æ•°ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨æ—¶åˆå§‹åŒ–çš„ç‰¹æ€§ï¼Œå¯ä»¥å®ç°çº¿ç¨‹å®‰å…¨ã€‚

```c++
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton sInstance; // å±€éƒ¨local å†å‡½æ•°ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨æ—¶åˆå§‹åŒ–ã€‚
        return sInstance;
    }
private:
    Singleton() {}
};
```



### memcpy

### strcpy

### ç”Ÿäº§è€…æ¶ˆè´¹è€…

### è¯»è€…å†™è€…

### çº¿ç¨‹æ± ï¼Ÿ

### è·³è¡¨

150 è¡Œ

```c++
#include <iostream>
#include <cstring>
#include <cstdlib>
class Node {
public:
    int key;
    int value;
    int level;
    Node **nexts; // ä¸€ä¸ª Node* æ•°ç»„
    Node(int k, int v, int l) : key(k), value(v), level(l){
        nexts = new Node*[level];
        for (int i = 0; i < level; i++) {
            // è¿™é‡Œä¸€å®šè¦åˆå§‹åŒ–ä¸º nullptr!
            nexts[i] = nullptr;
        }
    }
};
class Skiplist {
public:
    Skiplist(int _max_level) : max_level(_max_level), cur_level(0) {
        header = new Node(0, 0, max_level);
    }
    // æ˜¾ç¤º
    void display_list() {
        std::cout << "\n*****Skip List*****"<<"\n"; 
        for (int i = 0; i < cur_level; i++) {
            Node *node = header->nexts[i]; 
            std::cout << "Level " << i << ": ";
            while (node != NULL) {
                std::cout << node->key << ":" << node->value << ";";
                node = node->nexts[i];
            }
            std::cout << std::endl;
        }
        std::cout << "\n*****END*****"<<"\n"; 
    }
    // return -1 if not find
    int search(int key) {
        Node *cur = header;
        // å†å‘ä¸‹ è¿™é‡Œæ˜¯ä»é«˜å±‚åˆ°åº•å±‚
        for (int i = cur_level - 1; i >= 0; i--) {
            // å…ˆå‘å³ å¦‚æœä¸‹ä¸€ä¸ªèŠ‚ç‚¹ key æ›´å°ï¼Œå°±å¾€å³èµ°
            while (cur->nexts[i] && cur->nexts[i]->key < key) {
                cur = cur->nexts[i];
            }
        }
        // æŒ‡å‘è¦æŸ¥æ‰¾çš„ Node
        cur = cur->nexts[0];
        if (cur && cur->key == key) {
            return cur->value;
        }
        else {
            return -1;
        }
    }
    void insert(int key, int value) {
        Node *cur = header;
        // ç”¨ä¸€ä¸ª pres è®°å½•æŸ¥æ‰¾è·¯å¾„æœ€å³è¾¹çš„èŠ‚ç‚¹ï¼Œè®°å¾—ç½®ä¸ºé›¶
        Node *pres[max_level];
        memset(pres, 0, sizeof(Node*) * max_level);

        for (int i = cur_level - 1; i >= 0; i--) {
            while (cur->nexts[i] && cur->nexts[i]->key < key) {
                cur = cur->nexts[i];
            }
            // è®°å½•æ¯ä¸€å±‚æœ€å³çš„èŠ‚ç‚¹
            pres[i] = cur;
        }
        cur = cur->nexts[0];
        // å·²ç»æœ‰è¿™ä¸ª key äº†
        if (cur && cur->key == key) {
            cur->value = value;
            return;
        }

        if (cur == nullptr || cur->key != key) {
            int rand_level = get_random_level();
            // å¦‚æœå±‚æ•°å˜å¤šäº†ï¼Œè¦æ›´æ–° pres å’Œ cur_levelï¼ï¼
            if (rand_level > cur_level) {
                for (int l = cur_level; l < rand_level; l++) {
                    pres[l] = header;
                }
                cur_level = rand_level;
            }

            Node *node = new Node(key, value, rand_level);
            
            for (int l = 0; l < rand_level; l++) {
                node->nexts[l] = pres[l]->nexts[l];
                pres[l]->nexts[l] = node;
            }
            return;
        }
    }

    void delete_element(int key) {
        Node *cur = header;
        Node *pres[max_level];
        memset(pres, 0, sizeof(Node*) * max_level);

        for (int i = cur_level - 1; i >= 0; i--) {
            while (cur->nexts[i] && cur->nexts[i]->key < key) {
                cur = cur->nexts[i];
            }
            pres[i] = cur;
        }
        cur = cur->nexts[0];

        if (cur && cur->key == key) {
            for (int l = 0; l < cur->level; l++) {
                pres[l]->nexts[l] = cur->nexts[l];
            }
        }

        // Remove levels which have no elements
        while (cur_level > 0 && header->nexts[cur_level] == nullptr) {
            cur_level--; 
        }
        delete cur;
        return;
    }
private:
    int get_random_level() {
        int l = 1;
        while (rand() %  2) {
            l++;
        }
        return (l < max_level ? l : max_level);
    }

    int max_level;
    int cur_level;
    Node *header;
};


int main() {
    Skiplist sl(5);
    sl.display_list();
    sl.insert(1, 1);
    sl.display_list();

    sl.insert(2, 2);
    sl.insert(3, 3);
    sl.insert(4, 4);
    sl.insert(5, 5);
    sl.insert(6, 6);
    sl.insert(7, 7);
    sl.insert(8, 8);
    sl.display_list();
    
    sl.delete_element(3);
    sl.insert(8, 10);
    sl.display_list();
    for (int i = 0; i <= 8; i++) {
        std::cout << i << " : " << sl.search(i) << std::endl;
    }


    return 0;
}
```

### å­—ç¬¦ä¸² Spilit

```c++
// è¿™é‡Œæ²¡å¿…è¦ const string &
void split(std::string str, std::string pattern, vector<std::string> &result) {
    int pos = 0;
    str += pattern; // æ‰©å±•å­—ç¬¦ä¸²ä»¥æ–¹ä¾¿æ“ä½œï¼Œåˆ«å¿˜äº†è¿™ä¸€æ­¥
    int size = str.size();
    int cur_pos = 0;
    // è¿™é‡Œæ‹¬å·ä¸è¦åŠ é”™äº†
    while ((pos = str.find(pattern, cur_pos)) != string::npos)
    {
        std::string s = str.substr(cur_pos, pos - cur_pos);
        if (s != "")
            result.push_back(s);
        cur_pos = pos + pattern.size();
    }
}
```

