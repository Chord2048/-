# æ‰‹æ’•

[TOC]

### å †

### å¹¶æŸ¥é›†

### å‰ç¼€æ ‘

### LRU

```c++
class LRUCache {
public:
    class Node {
    public:
        int key;
        int val;
        Node *next;
        Node *prev;
        Node (int _key = -1, int _val = -1, Node *_next = nullptr, Node *_prev = nullptr) : key(_key), val(_val), next(_next), prev(_prev) {};        
    };
    
    unordered_map<int, Node*> mp;
    Node *head;
    Node *tail;    
    int capacity;
    int size;
    
    LRUCache(int capacity) : capacity(capacity), size(0) {
        head = new Node;
        tail = new Node;
        head->next = tail;
        tail->prev = head;
    }

    void release(Node *node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void move_head(Node *node) {
        Node *next = head->next;
        node->next = next;
        node->prev = head;
        head->next = node;
        next->prev = node;
    }

    int get(int key) {
        if (mp.find(key) == mp.end()) {
            return -1;
        }
        Node *node = mp[key];
        release(node);
        move_head(node);
        return node->val;
    }
    

    void put(int key, int value) {
        if (mp.find(key) != mp.end()) {
            Node *node = mp[key];
            // æ›´æ–°value
            node->val = value;
            
            // é‡æ–°æ’åˆ°å‰é¢
            release(node);
            move_head(node);
        }
        else {
            // æ»¡äº†å…ˆåˆ ï¼Œä»é“¾è¡¨å’Œå“ˆå¸Œé‡Œåˆ æ‰ï¼Œæ³¨æ„size--
            if (capacity == size) {
                Node *removed = tail->prev;
                release(removed);
                mp.erase(removed->key);
                delete removed;
                size--;
            }
            
            // åŠ æ–°èŠ‚ç‚¹ï¼ŒåŠ å…¥é“¾è¡¨å’Œå“ˆå¸Œï¼Œsize++
            Node *node = new Node(key, value);
            move_head(node);
            mp[key] = node;
            size++;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### LFU

### ğŸ‰ğŸ‰ğŸ‰ å•ä¾‹æ¨¡å¼

https://shengyu7697.github.io/cpp-singleton-pattern/

#### é¥¿æ±‰æ¨¡å¼

ç¼ºé»æ˜¯å¦‚æœè©² Singleton **åˆå§‹åŒ–å¾ˆè€—æ™‚çš„è©±æœƒä½”ç”¨åˆ°é€²å…¥ main å‰çš„æ™‚é–“**ï¼Œå„ªé»æ˜¯åœ¨é€²å…¥ main ä¹‹å‰å°±å°‡ Singleton åˆå§‹åŒ–å¥½ï¼Œæ‰€ä»¥**ä¸æœƒæœ‰ thread-safe åŸ·è¡Œç·’å®‰å…¨**å•é¡Œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯åœ¨**å¤šå€‹ Singleton æœ‰ç›¸ä¾é—œä¿‚çš„è©±æœƒç”¢ç”Ÿå•é¡Œ**ï¼Œä¾‹å¦‚ SingletonA å’Œ SingletonB éƒ½æ¡ç”¨äº†é¤“æ¼¢æ¨¡å¼ã€‚

```c++
// g++ cpp-singleton-hungry.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
using namespace std;

class Singleton {
public:
    // é™æ€æ–¹æ³•ï¼Œè¿”å›å¼•ç”¨æˆ–è€…æŒ‡é’ˆã€‚
    static Singleton& getInstance() {
        this_thread::sleep_for(chrono::seconds(1));
        return sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }

    static Singleton sInstance;
    // æˆ–è€… static Singleton *instance
};
// éœ€è¦åˆå§‹åŒ–ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„ // å¦‚æœæ˜¯æŒ‡é’ˆ Singleton Singleton::sInstance = new Singleton;
// éœ€è¦ä¼ å…¥ç±»å‹åï¼Œå…¶å®å°±æ˜¯å®šä¹‰ä¸€ä¸ªé™æ€å˜é‡
Singleton Singleton::sInstance;

int main() {
    cout << "main" << endl;
    thread t1([]{
        cout << "singleton addr: " << &Singleton::getInstance() << endl;
    });
    cout << "singleton addr: " << &Singleton::getInstance() << endl;
    // åˆ«å¿˜äº† join
    t1.join();
    return 0;
}
```



#### æ‡’æ±‰æ¨¡å¼

å»¶é²åˆå§‹åŒ– (Lazy Initialization)ï¼Œé€™åœ¨ä¸€äº›åˆå§‹åŒ–æ™‚æ¶ˆè€—è¼ƒå¤§çš„æƒ…æ³æœ‰å¾ˆå¤§å„ªå‹¢ã€‚

ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

```c++
// g++ cpp-singleton-hungry.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
using namespace std;
class Singleton {
public:
    // é™æ€æ–¹æ³•ï¼Œè¿”å›å¼•ç”¨æˆ–è€…æŒ‡é’ˆã€‚
    static Singleton& getInstance() {
    	if (instance == nullptr) {
    		instance = new Singleton();
    	}
        this_thread::sleep_for(chrono::seconds(1));
        // è¿”å›è§£å¼•ç”¨
        return *sInstance;
    }
private:
	// ç§æœ‰çš„æ„é€ å‡½æ•°
    Singleton() {}
    static Singleton *instance;
};
// staticå˜é‡ç±»å¤–åˆå§‹åŒ–
Singleton* Singleton::sInstance = nullptr;
...
```

#### çº¿ç¨‹å®‰å…¨æ‡’æ±‰

##### æ™®é€šé”

```c++
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

class Singleton {
public:
    static Singleton& getInstance() {
        // è¿™é‡Œä¸Šä¸ªé”
        lock_guard<std::mutex> lock(sMutex);
        if (sInstance == nullptr) {
            this_thread::sleep_for(chrono::seconds(1));
            sInstance = new Singleton();
        }
        return *sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }
	// static mutexå¯¹è±¡
    static mutex sMutex;
    static Singleton* sInstance;
};

// åŠ ä¸€ä¸ªstatic é”
mutex Singleton::sMutex;
Singleton* Singleton::sInstance = nullptr;

int main() {
    cout << "main" << endl;
    thread t1([]{
        cout << "singleton addr: " << &Singleton::getInstance() << endl;
    });
    cout << "singleton addr: " << &Singleton::getInstance() << endl;
    t1.join();
    return 0;
}
```

##### åŒé‡é”

é »ç¹åœ°å‘¼å« getInstance æœƒé€ æˆ race condition å•é¡Œï¼Œç”¢ç”Ÿæ•ˆèƒ½ä½è½çš„æƒ…å½¢ï¼Œå› æ­¤æœ‰äº†é›™é‡æª¢æ¸¬ä¸Šé–ç‰ˆ Double-Checked Locking é€™å€‹ç‰ˆæœ¬çš„æ”¹è‰¯

è¿˜æ˜¯æœ‰é—®é¢˜ï¼šç•¶æœ‰ä¸€å€‹åŸ·è¡Œç·’åœ¨åŸ·è¡Œ `sInstance = new Singleton();`ï¼Œæœ‰å¦å¤–ä¸€å€‹åŸ·è¡Œç·’åœ¨æª¢æŸ¥ç¬¬ä¸€å€‹ `sInstance == nullptr` æ™‚å¾ˆæœ‰å¯èƒ½å‡ºç¾å•é¡Œ

å› ç‚º `sInstance = new Singleton();` é€™èªå¥æœƒåˆ†æˆä¸‰å€‹æ­¥é©Ÿï¼Œ
Step 1: **Allocate** memory to hold a Singleton object. è¨˜æ†¶é«”é…ç½®
Step 2: **Construct** a Singleton object in the allocated memory. åœ¨å·±ç¶“é…ç½®çš„è¨˜æ†¶é«”ä¸Šå»ºæ§‹ Singleton ç‰©ä»¶
Step 3: Make sInstance **point to** the allocated memory. å°‡ sInstance æŒ‡å‘é…ç½®çš„è¨˜æ†¶é«”

1-3-2 å…ˆæŒ‡å‘ä½†æ²¡æœ‰ç”¨æ„é€ å‡½æ•°ï¼Œè¿™æ—¶å€™è¢«å…¶ä»–çº¿ç¨‹ç›´æ¥æ‹¿æ¥ç”¨äº†ã€‚

```c++
// g++ cpp-singleton-lock2.cpp -std=c++11 -pthread
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

class Singleton {
public:
    static Singleton& getInstance() {
        if (sInstance == nullptr) {
            // ç©ºäº†æ‰ä¸Šé”ï¼Œè¿™æ ·å†åˆå§‹åŒ–å®Œäº†å°±ä¸ä¼šç«äº‰äº†ã€‚
            lock_guard<std::mutex> lock(sMutex);
            // æ‹¿åˆ°é”å†æ£€æŸ¥ä¸€æ¬¡
            if (sInstance == nullptr) {
                sInstance = new Singleton();
            }
        }
        // åˆå§‹åŒ–è¿‡äº†ï¼Œç›´æ¥è¿”å›ï¼Œä¸ç”¨ä¸Šé”ã€‚
        return *sInstance;
    }

private:
    Singleton() {
        cout << "Singleton constructor\n";
    }

    static mutex sMutex;
    static Singleton* sInstance;
};

mutex Singleton::sMutex;
Singleton* Singleton::sInstance = nullptr;
```

#### èƒŒä¸€æ‰‹

```c++
#include <iostream>
#include <thread>

class LazySingleton {
public:
    static LazySingleton *getInstance() {
        if (instance_ptr == nullptr) {
            instance_ptr = new LazySingleton;
        }
        return instance_ptr;
    }
private:
    LazySingleton () {}
    static LazySingleton *instance_ptr;
};
LazySingleton *LazySingleton::instance_ptr = nullptr;

class HungrySingleton {
public:
    static HungrySingleton *getInstance() {
        return instance_ptr;
    }

private:
    HungrySingleton () {}
    static HungrySingleton *instance_ptr;
};
HungrySingleton *HungrySingleton::instance_ptr = new HungrySingleton;

int main() {
    std::cout << "test lazy" << std::endl;
    auto s1 = LazySingleton::getInstance();
    auto s2 = LazySingleton::getInstance();
    std::cout << s1 << " " << (s1 == s2) << std::endl;

    std::cout << "test hungry" << std::endl;
    auto s3 = HungrySingleton::getInstance();
    auto s4 = HungrySingleton::getInstance();
    std::cout << s3 << " " << (s3 == s4) << std::endl;
    return 0;
}
```

#### æœ€å¥½ç”¨çš„æ‡’æ±‰

// å±€éƒ¨local å†å‡½æ•°ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨æ—¶åˆå§‹åŒ–çš„ç‰¹æ€§ï¼Œå¯ä»¥å®ç°çº¿ç¨‹å®‰å…¨ã€‚

```c++
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton sInstance; // å±€éƒ¨local å†å‡½æ•°ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨æ—¶åˆå§‹åŒ–ã€‚
        return sInstance;
    }
private:
    Singleton() {}
};
```



### memcpy

### strcpy

### ç”Ÿäº§è€…æ¶ˆè´¹è€…

### è¯»è€…å†™è€…

### çº¿ç¨‹æ± ï¼Ÿ